<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="kubernetes,docker," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="#1.1 Kubernetes是什么#

它是基于容器技术的分布式架构领先方案；
Kubernetes是一个开放的开发平台；
Kubernetes是一个完备的分布式系统支撑平台。1.2 为什么要用Kubernetes

使用Kubernetes的理由很多，最根本的一个理由就是：IT从来都是一个由新技术驱动的行业。

使用Kubernetes所带来的好处：


最直接的感受就是我们可以“轻装上阵”地">
<meta property="og:type" content="article">
<meta property="og:title" content="第一章 认识kubernetes">
<meta property="og:url" content="http://blog.710x.com/2017/03/14/第一章-认识kubernetes/index.html">
<meta property="og:site_name" content="时记">
<meta property="og:description" content="#1.1 Kubernetes是什么#

它是基于容器技术的分布式架构领先方案；
Kubernetes是一个开放的开发平台；
Kubernetes是一个完备的分布式系统支撑平台。1.2 为什么要用Kubernetes

使用Kubernetes的理由很多，最根本的一个理由就是：IT从来都是一个由新技术驱动的行业。

使用Kubernetes所带来的好处：


最直接的感受就是我们可以“轻装上阵”地">
<meta property="og:updated_time" content="2017-03-14T13:25:42.709Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第一章 认识kubernetes">
<meta name="twitter:description" content="#1.1 Kubernetes是什么#

它是基于容器技术的分布式架构领先方案；
Kubernetes是一个开放的开发平台；
Kubernetes是一个完备的分布式系统支撑平台。1.2 为什么要用Kubernetes

使用Kubernetes的理由很多，最根本的一个理由就是：IT从来都是一个由新技术驱动的行业。

使用Kubernetes所带来的好处：


最直接的感受就是我们可以“轻装上阵”地">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '6396536421875713000',
      author: '秋林'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.710x.com/2017/03/14/第一章-认识kubernetes/"/>





  <title> 第一章 认识kubernetes | 时记 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">时记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">时间累积，知识积累</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.710x.com/2017/03/14/第一章-认识kubernetes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiulin Yao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时记">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                第一章 认识kubernetes
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T20:18:37+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/14/第一章-认识kubernetes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/第一章-认识kubernetes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>#1.1 Kubernetes是什么#</p>
<ol>
<li>它是基于容器技术的分布式架构领先方案；</li>
<li>Kubernetes是一个开放的开发平台；</li>
<li>Kubernetes是一个完备的分布式系统支撑平台。<h1 id="1-2-为什么要用Kubernetes"><a href="#1-2-为什么要用Kubernetes" class="headerlink" title="1.2 为什么要用Kubernetes"></a>1.2 为什么要用Kubernetes</h1></li>
</ol>
<p>使用Kubernetes的理由很多，最根本的一个理由就是：IT从来都是一个由新技术驱动的行业。</p>
<blockquote>
<p>使用Kubernetes所带来的好处：</p>
</blockquote>
<ol>
<li>最直接的感受就是我们可以“轻装上阵”地开发复杂系统了；</li>
<li>使用Kubernetes就是在全面拥抱微服务架构；</li>
<li>我们的系统可以随时随地整体“搬迁”到公有云上；</li>
<li>Kubernetes系统架构具备了超强的横向扩容能力。</li>
</ol>
<p>#1.3 Kubernetes基本概念和术语#</p>
<p>在Kubernetes中，Node、Pod、Replication Controller、Service等概念都可以看作一种资源对象，通过Kubernetes提供的Kubectl工具或者API调用进行操作，并保存在etcd中。</p>
<p>##1.3.1 Node（节点）##</p>
<p>Node（节点）是Kubernetes集群中相对于Master而言的工作主机，在较早的版本中也被称为Minion。Node可以是一台物理主机，也可以是一台虚拟机（VM）。在每个Node上运行用于启动和管理Pid的服务Kubelet，并能够被Master管理。在Node上运行的服务进行包括Kubelet、kube-proxy和docker daemon。</p>
<blockquote>
<p>Node信息如下：</p>
</blockquote>
<ol>
<li>Node地址：主机的IP地址，或者Node ID。</li>
<li>Node运行状态：包括Pending、Running、Terminated三种状态。</li>
<li>Node Condition（条件）：描述Running状态Node的运行条件，目前只有一种条件—-Ready。Ready表示Node处于健康状态，可以接收从Master发来的创建Pod的指令。</li>
<li>Node系统容量：描述Node可用的系统资源，包括CPU、内存数量、最大可调度Pod数量等。</li>
<li>其他：Node的其他信息，包括实例的内核版本号、Kubernetes版本号、Docker版本号、操作系统名称等。</li>
</ol>
<hr>
<p>###Node的管理###</p>
<p>Node通常是物理机、虚拟机或者云服务商提供的资源，并不是由Kubernetes创建的。我们说Kubernetes创建一个Node，仅仅表示Kubernetes在系统内部创建了一个Node对象，创建后即会对其进行一系列健康检查，包括是否可以连通、服务是否正确启动、是否可以创建Pod等。如果检查未能通过，则该Node将会在集群中被标记为不可用（Not Ready）。</p>
<p>###使用Node Controller对Node进行管理###</p>
<p>Node Controller是Kubernetes Master中的一个组件，用于管理Node对象。它的两个主要功能包括：集群范围内的Node信息同步，以及单个Node的生命周期管理。<br>Node信息同步可以通过kube-controller-manager的启动参数–node-sync-period设置同步的时间周期。</p>
<p>###Node的自注册###</p>
<p>当Kubelet的–register-node参数被设置为true（默认值即为true）时，Kubelet会向apiserver注册自己。这也是Kubernetes推荐的Node管理方式。</p>
<blockquote>
<p>Kubelet进行自注册的启动参数如下：</p>
</blockquote>
<ol>
<li>–apiservers=: apiserver地址；</li>
<li>–kubeconfig=: 登录apiserver所需凭据/证书的目录；</li>
<li>–cloud_provider=: 云服务商地址，用于获取自身的metadata；</li>
<li>–register-node=: 设置为true表示自动注册到apiserver。</li>
</ol>
<p>###手动管理Node###</p>
<p>Kubernetes集群管理员也可以手工创建和修改Node对象。当需要这样操作时，先要将Kubelet启动参数中的–register-node参数的值设置为false。这样，在Node上的Kubelet就不会把自己注册到apiserver中去了。</p>
<p>另外，Kubernetes提供了一种运行时加入或者隔离某些Node的方法。具体操作请参考第四章。</p>
<p>##1.3.2 Pod##</p>
<p>Pod是Kubernetes的最基本操作单元，包含一个活多个紧密相关的容器，类似于豌豆荚的概念。一个Pod可以被一个容器化的环境看作应用层的“逻辑宿主机”（Logical Host）。一个Pod中的多个容器应用通常是紧耦合的。Pod在Node上被创建、启动或者销毁。</p>
<p>为什么Kubernetes使用Pod在容器之上再封装一层呢？一个很重要的原因是，Docker容器之间的通信受到Docker网络机制的限制。在Docker的世界中，一个容器需要link方式才能访问另一个容器提供的服务（端口）。大量容器之间的link将是一个非常繁重的工作。通过Pod的概念将多个容器组合在一个虚拟的“主机”内，可以实现容器之间仅需要通过Localhost就能相互通信了。</p>
<blockquote>
<p>一个Pod中的应用容器共享同一组资源，如下所述：</p>
</blockquote>
<ol>
<li>PID命名空间：Pod中的不同应用程序可以看到其他应用程序的进程ID；</li>
<li>网络命名空间：Pod中的多个容器能够访问同一个IP和端口范围；</li>
<li>IPC命名空间：Pod中的多个容器能够使用SystemV IPC或者POSIX消息队列进行通信；</li>
<li>UTS命名空间：Pod中的多个容器共享一个主机名；</li>
<li>Volumes（共享存储卷）：Pod中的各个容器可以访问在Pod级别定义的Volumes。<br>###对Pod的定义###</li>
</ol>
<p>对Pod的定义通过Yaml或Json格式的配置文件来完成。下面的配置文件将定义一个名为redis-slave的Pod，其中kind为Pod。在spec中主要包含了Containers（容器）的定义，可以定义多个容器。</p>
<pre><code>apiVersion: v1
kind: Pod
metadata:
name: redis-slave
labels:
name: redis-slave
spec:
containers:

    - name: slave
      image: kubeguide/guestbook-redis-slave
      env:
      - name: GET_HOSTS_FROM
    value: env
      ports:
      - containerPort: 6379
</code></pre><p>Pod的生命周期是通过Replication Controller来管理的。Pod的生命周期过程包括：通过模板进行定义，然后分配到一个Node上运行，在Pod所含容器运行结束后Pod也结束。在整个过程中，Pod处于一下4种状态之一：</p>
<ol>
<li>Pending：Pod定义正确，提交到Master，但其所包含的容器镜像还未完成创建。通常Master对Pod进行调度需要一些时间，之后Node对镜像进行下载也需要一些时间；</li>
<li>Running：Pod已被分配到某个Node上，且其包含的所有容器镜像都已经创建完成，并成功运行起来；</li>
<li>Succeeded：Pod中所有容器都成功结束，并且不会被重启，这是Pod的一种最终状态；</li>
<li><p>Failed：Pod中所有容器都结束了，但至少一个容器是以失败状态结束的，这也是Pod的一种最终状态。</p>
<p>Kubernetes为Pod设计了一套独特的网络配置，包括：为每个Pod分配一个IP地址，使用Pod名作为容器间通信的主机名等。关于Kubernetes网络的设计原理将在第2章进行详细说明。</p>
</li>
</ol>
<p>另外，不建议在Kubernetes的一个Pod内运行相同应用的多个实例。</p>
<p>##1.3.3 Label（标签）##</p>
<p>Label是Kubernetes系统中的一个核心概念。Label以key/value键值对的形式附加到各种对象上，如Pod、Service、RC、Node等。Label定义了这些对象的可识别属性，用来对它们进行管理和选择。Label可以在创建时附加到对象上，也可以在对象创建后通过API进行管理。</p>
<p>在为对象定义好Label后，其他对象就可以使用Label Selector（选择器）来定义其作用的对象了。</p>
<p>Label Selector的定义由多个逗号分隔的条件组成。</p>
<pre><code>&quot;labels&quot;: {
&quot;key1&quot;: &quot;value1&quot;,
&quot;key2&quot;: &quot;value2&quot;
}
</code></pre><p>当前有两种Label Selector：基于等式的（Equality-based）和基于集合的（Set-based），在使用时可以将多个Label进行组合来选择。</p>
<blockquote>
<p>基于等式的Label Selector使用等式类的表达式来进行选择：</p>
</blockquote>
<ol>
<li>name = redis-slave: 选择所有包含Label中key=”name”且value=”redis-slave”的对象；</li>
<li>env != production: 选择所有包括Label中的key=”env”且value不等于”production”的对象。</li>
</ol>
<blockquote>
<p>基于集合的Label Selector使用集合操作的表达式来进行选择：</p>
</blockquote>
<ol>
<li>name in (redis-master, redis-slave): 选择所有包含Label中的key=”name”且value=”redis-master”或”redis-slave”的对象；</li>
<li>name not in (php-frontend): 选择所有包含Label中的key=”name”且value不等于”php-frontend”的对象。</li>
</ol>
<p>在某些对象需要对另一些对象进行选择时，可以将多个Label Selector进行组合，使用逗号”,”进行分隔即可。基于等式的LabelSelector和基于集合的Label Selector可以任意组合。例如：</p>
<pre><code>name=redis-slave,env!=production
name not in (php-frontend),env!=production
</code></pre><p>##1.3.4 Replication Controller（RC）##</p>
<p>Replication Controller是Kubernetes系统中的核心概念，用于定义Pod副本的数量。在Master内，Controller Manager进程通过RC的定义来完成Pod的创建、监控、启停等操作。</p>
<p>根据Replication Controller的定义，Kubernetes能够确保在任意时刻都能运行用于指定的Pod“副本”（Replica）数量。如果有过多的Pod副本在运行，系统就会停掉一些Pod；如果运行的Pod副本数量太少，系统就会再启动一些Pod，总之，通过RC的定义，Kubernetes总是保证集群中运行着用户期望的副本数量。</p>
<p>同时，Kubernetes会对全部运行的Pod进行监控和管理，如果有需要（例如某个Pod停止运行），就会将Pod重启命令提交给Node上的某个程序来完成（如Kubelet或Docker）。</p>
<p>可以说，通过对Replication Controller的使用，Kubernetes实现了应用集群的高可用性，并大大减少了系统管理员在传统IT环境中需要完成的许多手工运维工作（如主机监控脚本、应用监控脚本、故障恢复脚本等）。</p>
<p>对Replication Controller的定义使用Yaml或Json格式的配置文件来完成。以redis-slave为例，在配置文件中通过spec.template定义Pod的属性（这部分定义与Pod的定义是一致的），设置spec.replicas=2来定义Pod副本的数量。</p>
<pre><code>apiVersion: v1
kind: ReplicationController
metadata:
name: redis-slave
labels: redis-slave
name: redis-slave
spec:
replicas: 2
selector:
name: redis-slave
template:
metadata:
labels:
name: redis-slave
spec:
container:

        - name: slave
          image: kubeguide/guestbook-redis-slave
          env:
          - name: GET_HOSTS_FROM
            value: env
          ports:
          - containerPort: 6379
</code></pre><p>通常，Kubernetes集群中不止一个Node，假设一个集群有3个Node，根据RC的定义，系统将可能在其中的两个Node上创建Pod。</p>
<p>##1.3.5 Service（服务）##</p>
<p>在Kubernetes的世界里，虽然每个Pod都会被分配一个单独的IP地址，这个IP地址会随时Pod的销毁而消失。这就引出一个问题：如果有一组Pod组成一个集群来提供服务，那么如何来访问它们呢？</p>
<p>Kubernetes的Service（服务）就是用来解决这个问题的核心概念。</p>
<p>一个Service可以看作一组提供相同服务的Pod的对外访问接口。Service作用于哪些Pod是通过Label Selector来定义的。</p>
<p>####对Service的定义####</p>
<p>对Service的定义同样使用Yaml或Json格式的配置文件来完成。以redis-slave服务的定义为例：</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
name: redis-slave
labels:
name: redis-slave
spec:
ports:

- port: 6379
selector:
    name: redis-slave
</code></pre><p>通过该定义，Kubernetes将会创建一个名为“redis-slave”的服务，并在6379端口上监听。spec.selector的定义表示该Service将包含所有具有”name=redis-slave”的Label的Pod。</p>
<p>在Pod正常启动后，系统将会根据Service的定义创建出与Pod对应的Endpoint（端点）对象，以建立起Service与后端Pod的对应关系。随着Pod的创建、销毁，Endpoint对象也将被更新。Endpoint对象主要有Pod的IP地址和容器所需监听的端口号组成。</p>
<p>####Pod的IP地址和Service的Cluster IP地址####</p>
<p>Pod的IP地址是Docker Daemon根据docker0网桥的IP地址段进行分配的，但Service的Cluster IP地址是Kubernetes系统中的虚拟IP地址，由系统动态分配。Service的Cluster IP地址相对于Pod的IP地址来说相对稳定，Service被创建时即被分配一个IP地址，在销毁该Service之前，这个IP地址都不会再变化了。而Pod在Kubernetes集群中生命周期较短，可能被ReplicationContrller销毁、再次创建，新创建的Pod将会分配一个新的IP地址。</p>
<p>####外部访问Service####</p>
<p>由于Service对象在Cluster IP Range池中分配到的IP只能在内部访问，所以其他Pod都可以无障碍地访问到它。到如果这个Service作为前端服务，准备为集群外的客户端提供服务，我们就需要给这个服务提供公共IP了。</p>
<p>Kubernetes支持两种对外提供服务的Service的type定义：NodePort和LoadBalancer。</p>
<p><strong>NodePort</strong></p>
<p>在定义Service时指定spec.type=NodePort，并指定spec.ports.nodePort的值，系统就会在Kubernetes集群中的每个Node上打开一个主机上的真实端口号。这样，能够访问Node的客户端都就能通过这个端口号访问到内部的Service了。</p>
<p>以php-frontend service的定义为例，nodePort=80，这样，在每一个启动了该php-frontend Pod的Node节点上，都会打开80端口。</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
name: frontend
labels:
name: frontend
spec:
type: NodePort
ports:

- port: 80
  nodePort: 30001
selector:
    name: frontend
</code></pre><p><strong>LoadBalancer</strong></p>
<p>如果云服务商支持外接负载均衡器，则可以通过spec.type=LoadBalaner定义Service，同时需要制定负载均衡器的IP地址。使用这种类型需要指定Service的nodePort和clusterIP。例如：</p>
<pre><code>apiVersion: v1
kind: Service
metadata: {
&quot;kind&quot; &quot;Service&quot;,
&quot;apiVersion&quot;: &quot;v1&quot;,
&quot;metadata&quot;: {
&quot;name&quot;: &quot;my-service&quot;
},
&quot;spec&quot;: {
&quot;type&quot;: &quot;LoadBalaner&quot;,
&quot;clusterIP&quot;: &quot;10.0.171.239&quot;,
&quot;selector&quot;: {
&quot;app&quot;: &quot;MyApp&quot;
},
&quot;ports&quot;: [
{
&quot;protocol&quot;: &quot;TCP&quot;,
&quot;port&quot;: 80,
&quot;targetPort&quot;: 9376,
&quot;nodePort&quot;: 30061
}
],
},
&quot;status&quot;: {
&quot;loadBalancer&quot;: {
&quot;ingress&quot;: [
{
&quot;ip&quot;: &quot;146.148.47.155&quot;
}
]
}
}
}
</code></pre><p>在这个例子中，status.loadBalancer.ingress.ip设置的146.146.47.155为云服务商提供的负载均衡器的IP地址。</p>
<p>之后，对该Service的访问请求将会通过LoadBalancer转发到后端Pod上去，负载分发的实现方式则依赖于云服务上提供的LoadBalancer的实现机制。</p>
<p>##1.3.6 Volume（存储卷）##</p>
<p>Volume是Pod中能够被多个容器访问的共享目录。Kubernetes的Volume概念与Docker的Volume比较类似，但不完全相同。Kubernetes中的Volume与Pod生命周期相同，但与容器的生命周期不相关。当容器终止或者重启时，Volume中的数据也不会丢失。另外，Kubernetes支持多种类型的Volume，并且一个Pod可以同时使用任意多个Volume。<br>Kubernetes提供了非常丰富的Volume类型，下面逐一进行说明。</p>
<ol>
<li>EmptyDir：一个EmptyDir Volume是在Pod分配到Node时创建的。从它的名称就可以看出，它的初始内容为空。在同一个Pod中所有容器可以读和写EmptyDir中的相同文件。当Pod从Node上移除时，EmptyDir中的数据也会永久删除。</li>
<li>hostPath：在Pod上挂载宿主机上的文件或目录。</li>
<li>gcePersistentDisk：使用这种类型的Volume表示使用谷歌计算引擎（Google Compute Engine，GCE）上永久磁盘（Persistent Disk，PD）上的文件。与EmptyDir不同，PD上的内容会永久保存，当Pod被删除时，PD只是被卸载（Unmount），但不会被删除。需要注意的是，你需要先创建一个永久磁盘（PD）才能使用gcePersistentDisk。</li>
<li>awsElasticBlockStore：与GCE类似，该类型的Volume使用Amazon提供的Amazon Web Service（AWS）的EBS Volume，并可以挂在到Pod中去。需要注意到是，需要首先创建一个EBS Volume才能使用awsElasticBlockStore。</li>
<li>nfs：使用NFS（网络文件系统）提供的共享目录挂载到Pod中。在系统中需要一个运行中的NFS系统。</li>
<li>iscsi：使用iSCSI存储设备上的目录挂载到Pod中。</li>
<li>glusterfs：使用开源GlusterFS网络文件系统的目录挂载到Pod中。</li>
<li>rbd：使用Linux块设备共享存储（Rados Block Device）挂载到Pod中。</li>
<li>gitRepo：通过挂载一个空目录，并从GIT库clone一个git respository以供Pod使用。</li>
<li>secret：一个secret volume用于为Pod提供加密的信息，你可以将定义在Kubernetes中的secret直接挂载为文件让Pod访问。secret volume是通过tmfs（内存文件系统）实现的，所以这种类型的volume总是不会持久化的。</li>
<li>persistentVolumeClaim：从PV（PersistentVolume）中申请所需的空间，PV通常是一种网络存储，例如GCEPersistentDisk、AWSElasticBlockStore、NFS、iSCSI等。<br>##1.3.7 Namespace（命名空间）##</li>
</ol>
<p>Namespace（命名空间）是Kubernetes系统中的另一个非常重要的概念，通过将系统内部的对象“分配”到不同的Namespace中，形成逻辑上分组的不同项目、小组或用户组，便于不同的分组在共享使用整个集群的资源的同时还能被分别管理。<br>Kubernetes集群在启动后，会创建一个名为“default”的Namespace，通过Kubectl可以查看到。<br>使用Namespace来组织Kubernetes的各种对象，可以实现对用户的分组，即“多租户”管理。对不同的租户还可以进行单独的资源配额设置和管理，使得整个集群的资源配置非常灵活、方便。</p>
<p>##1.3.8 Annotation（注解）##</p>
<p>Annotation与Label类似，也使用key/value键值对的形式进行定义。Label具有严格的命名规则，它定义的是Kubernetes对象的元数据（Metadata），并且用于Label Selector。Annotation则是用户任意定义的“附加”信息，以便于外部工具进行查找。<br>用Annotation来记录的信息包括：</p>
<ol>
<li>build信息、release信息、Docker镜像信息等，例如时间戳、release id号、PR号、镜像hash值、docker registry地址等；</li>
<li>日志库、监控库、分析库等资源库的地址信息；</li>
<li>程序调试工具信息，例如工具名称、版本号等；</li>
<li>团队的联系信息，例如电话号码、负责人名称、网址等。<br>##1.3.9 小结##</li>
</ol>
<p>上述这些组件是Kubernetes系统的核心组件，它们共同构成了Kubernetes系统的框架和计算模型。通过对它们进行灵活组合，用户就可以快速、方便地对容器集群进行配置、创建和管理。<br>除了以上核心组件，在Kubernetes系统中还有许多可供配置的资源对象，例如LimitRange、ResourceQuota。另外，一些系统内部使用的对象Binding、Event等请参考Kubernetes的API文档。</p>
<p>#1.4 Kubernetes总体架构#</p>
<p>Kubernetes集群由两类节点组成：Master和Node。在Master上运行etcd、API Server、Controller Manager和Scheduler四个组件，其中后三个组件构成了Kubernetes的总控中心，负责对集群中所有资源进行管理和调度。在每个Node上运行Kubelet、Proxy和Docker Daemon三个组件，负责对本节点上的Pod的生命周期进行管理，以及实现服务代理的功能。另外在所有节点上都可以运行Kubectl命令行工具，它提供了Kubernetes的集群管理工具集。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/kubernetes/" rel="tag"># kubernetes</a>
          
            <a href="/tags/docker/" rel="tag"># docker</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/12/Linux硬盘挂载/" rel="next" title="Linux硬盘挂载">
                <i class="fa fa-chevron-left"></i> Linux硬盘挂载
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/03/14/第一章-认识kubernetes/"
           data-title="第一章 认识kubernetes" data-url="http://blog.710x.com/2017/03/14/第一章-认识kubernetes/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Qiulin Yao" />
          <p class="site-author-name" itemprop="name">Qiulin Yao</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/2081834604" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2172286167" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-2-为什么要用Kubernetes"><span class="nav-number">1.</span> <span class="nav-text">1.2 为什么要用Kubernetes</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qiulin Yao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"qiulin-blog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
